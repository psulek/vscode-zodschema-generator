import * as vscode from 'vscode';
import { isTypescriptFile, context } from './context';
import { previewPanel } from './command';
import * as ts2zod from 'ts-to-zod';
import path from 'path';

export const getContext = () => context;

const myScheme = 'zodschemagen';


export async function activate(ctx: vscode.ExtensionContext) {
    context.init(ctx);

    // async function showPreview(column: vscode.ViewColumn, textEditor?: vscode.TextEditor, uri?: vscode.Uri) {
    //     const isValidFile = (uri && isTypescriptFile(uri)) || (textEditor && isTypescriptFile(textEditor.document));
    //     if (!isValidFile) {
    //         return;
    //     }

    //     await context.waitForInit();

    //     previewPanel.show({
    //         viewColumn: column,
    //         fsPath: uri && uri.fsPath,
    //         textEditor: textEditor
    //     });
    // };

    // ctx.subscriptions.push(
    //     vscode.commands.registerTextEditorCommand(
    //         'zodschemagen.showPreview',
    //         textEditor => showPreview(vscode.ViewColumn.Beside, textEditor)
    //     ),

    //     vscode.commands.registerTextEditorCommand(
    //         'zodschemagen.reloadPreview',
    //         async _ => {
    //             // await context.waitForInit();
    //             // previewPanel.reload();
    //         })
    // );

    function showPreview(editor: vscode.TextEditor): void {
        if (editor.document.uri.scheme !== myScheme) {
            const uri = encodeLocation(editor.document.uri, editor.document.isUntitled);
            vscode.workspace.openTextDocument(uri).then(doc => vscode.window.showTextDocument(doc, editor.viewColumn! + 1));
        }
    }

    const myProvider = new class implements vscode.TextDocumentContentProvider {
        // emitter and its event
        onDidChangeEmitter = new vscode.EventEmitter<vscode.Uri>();
        onDidChange = this.onDidChangeEmitter.event;

        provideTextDocumentContent(uri: vscode.Uri): string {
            let content = '';
            const [target, isUntitled] = decodeLocation(uri);

            const editor = vscode.window.visibleTextEditors.find(x => x.document.uri.toString() === target.toString() && x.document.isUntitled === isUntitled);
            if (editor) {
                const editorText = editor.document.getText();
                try {
                    const result = ts2zod.generate({ sourceText: editorText, keepComments: true });
                    if (result.errors && result.errors.length > 0) {
                        content = result.errors.map(x => {
                            x = x.replace(/\n/g, '\n//');

                            return `//${x}`;
                        }).join('\n') + '\n\n';
                    }

                    const schemasFile = result.getZodSchemasFile('')
                        .replace(/\/\/ Generated by ts-to-zod/g, '')
                        .trim();
                    content += schemasFile;

                    if (schemasFile.length > 0) {
                        const inferredTypes = result.getInferredTypes('')
                            .replace(`// Generated by ts-to-zod`, '')
                            .replace(`import { z } from "zod";`, '')
                            .replace(`import * as generated from "";`, '')
                            .replace(/infer<typeof generated./g, 'infer<typeof ')
                            .trim();
                        if (inferredTypes.length > 0) {
                            content += `\n\n// inferred types:\n${inferredTypes}`;
                        }
                    }
                } catch (error) {
                    content = (error as Error).message;
                }
            }

            return content;
        }
    };
    ctx.subscriptions.push(
        vscode.workspace.registerTextDocumentContentProvider(myScheme, myProvider),

        vscode.commands.registerTextEditorCommand('zodschemagen.showPreview', showPreview),
        vscode.commands.registerTextEditorCommand('zodschemagen.showPreviewMenu', showPreview)
    );
}

// This method is called when your extension is deactivated
export function deactivate() { }

let seq = 0;


export function encodeLocation(uri: vscode.Uri, isUntitled: boolean): vscode.Uri {
    const query = JSON.stringify([uri.toString(), isUntitled]);
    const file = (path.parse(uri.fsPath).name ?? 'preview') + '.ts';

    return vscode.Uri.parse(`${myScheme}:${file}?${query}#${seq++}`);
}

export function decodeLocation(uri: vscode.Uri): [vscode.Uri, boolean] {
    const [target, isUntitled] = <[string, boolean]>JSON.parse(uri.query);
    return [vscode.Uri.parse(target), isUntitled];
}
